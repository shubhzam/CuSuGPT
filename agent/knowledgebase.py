from langgraph.graph import StateGraph,START,END

from dotenv import load_dotenv

from typing import TypedDict,List,Annotated,Literal

from langchain_openai import ChatOpenAI

from pydantic import BaseModel, Field 

from langgraph.graph.message import add_messages

from langchain.schema import SystemMessage,HumanMessage

from langchain_core.tools import tool

from langgraph.prebuilt import ToolNode, tools_condition

from langchain.prompts import ChatPromptTemplate

from langchain_core.output_parsers import JsonOutputParser

from prompt_library.knowledgebase_sys_msg import qrc_knowledgebase_system_message, current_date_prompt

from prompt_library.chart_sys_msg import chart_message

from datetime import datetime

import os

import pyodbc




def execute_sql_query(query: str) -> list:
    """
    Executes a SQL SELECT query on the SQL Server and returns the results as a list of dicts.
    
    Parameters:
        query (str): A SELECT query string.
    
    Returns:
        List[dict]: List of rows as dictionaries.
    """
    conn_str = (
        "DRIVER={ODBC Driver 17 for SQL Server};"
        "SERVER=216.48.191.98;"
        "DATABASE=Credit_GPT;"  # or Kredit_Bee_FC based on query
        "UID=ibsadmin;"
        "PWD=Viking@@ibs2023;"
    )
    try:
        with pyodbc.connect(conn_str) as conn:
            print("✅ Connection successful!")
    except Exception as e:
        print("❌ Connection failed:", e)
    try:
        with pyodbc.connect(conn_str, autocommit=True) as conn:
            cursor = conn.cursor()
            cursor.execute(query)
            columns = [column[0] for column in cursor.description]
            rows = cursor.fetchall()
            results = [dict(zip(columns, row)) for row in rows]
            print(f"✅ Query executed successfully. Rows fetched: {len(results)}")
            return results
    except Exception as e:
        print(f"❌ Error executing query: {e}")
        return []

result = execute_sql_query("""SELECT MAX([CreatedDate]) AS LatestCreatedDate, MIN([CreatedDate]) as OldestCreatedDate
FROM [CustomerSupportGPT].[dbo].[QRCKnowledgeBase];
""")

db_least_early_date = f"date of latest record in database (format :- yyyy-mm-dd) : {result[0]['LatestCreatedDate']}, date of oldest record in database : {result[0]['OldestCreatedDate']}"

# prompt  (CHANGE IN SYSTEM PROMPT)
system_message = f"""

You are an AI that only returns SQL SELECT queries based on user requests.
You are an expert in Microsoft SQL Server (T-SQL). Generate only valid SQL syntax
that works in SQL Server Management Studio (SSMS). Avoid any syntax, functions, 
or keywords from other SQL dialects such as MySQL, PostgreSQL, or SQLite. 
Do not use non-T-SQL keywords such as LIMIT, RETURNING, AUTO_INCREMENT, SERIAL,
ILIKE, ::, or USING in joins. Always use correct T-SQL equivalents such as TOP,
IDENTITY, CAST() or CONVERT(), and OFFSET/FETCH for pagination.
When needed, enclose reserved words or potentially ambiguous names in square
brackets. Use T-SQL data types (e.g., VARCHAR, INT, DATETIME) and T-SQL functions
(e.g., GETDATE(), ISNULL(), DATEDIFF()). Ensure that queries are optimized for 
compatibility with SSMS and SQL Server versions 2016 and above.

Return the result as a JSON object with a single key `query`, where the value is a valid SQL SELECT statement
as a single-line string, without newlines or formatting.
if sql query conditions are based dates and no date column is provided then by default use column:'CreatedDate'.
{db_least_early_date}.
{current_date_prompt}.

Use only the given schema. Do not guess column or table names.

Always clarify and use the best matching table and columns based on the user's natural language description.  
If unsure, choose the most relevant columns/tables described in the schema.

always provide entire raw data as output and do not add any extra characters or words to data.

Also return a boolean field named `sql_flag` which is True if the query is a COUNT/Aggregate query (like COUNT, SUM, AVG, MIN, MAX), and False otherwise.





{qrc_knowledgebase_system_message}
"""

class sqlobject(TypedDict):
    query : str = Field(description="""valid SQL Query generated by llm  """)
    is_count_query : bool = Field(description="""'True' if generated sql query is count query else 'False' """)


class stateobject(TypedDict):
    markdown : str = Field(description="""markdown converted data """)


class chartobject(TypedDict):
    i_Frame : str = Field(description="""html converted data """)
    flag : bool = Field(description="""'True' if data database retrieved data was converted into html i frame format else 'False' """)


markdown_message ="""

you are an an assistant specialized at transforming the data fetched from database into markdown format.
do not add any extra explanation on retrieved data like "
## Detailed Ticket Information".

"""

load_dotenv()

openai_key = os.getenv('OPENAI_API_KEY')

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.3, api_key=openai_key)

def data_fetcher(query):

    sql_format_input = [
    SystemMessage(content=system_message),
    HumanMessage(content=str(query))
    ]

    # result = chain.invoke({'input': query })
    result = llm.with_structured_output(sqlobject).invoke(sql_format_input)

    print(f"\n\nsql : {result.get("query")}, is_count_query : {result.get("is_count_query")}\n\n")

    query = result.get("query")

    response = execute_sql_query(query)
    
    markdown_format_input = [
    SystemMessage(content=markdown_message),
    HumanMessage(content=str(response))
]

    markdown_response = llm.with_structured_output(stateobject).invoke(markdown_format_input)

    # print(f"{markdown_response.get("markdown")}")

    chart_format_input = [
    SystemMessage(content=chart_message),
    HumanMessage(content=str(response))
]

    chart_response = llm.with_structured_output(chartobject).invoke(chart_format_input)
    print(chart_response)
    if result.get("is_count_query") == True:
        print("\n\nit is a count query\n\n")
        if len(response) > 1 and len(response) < 5:
            print(f"\n\nrow count is : {len(response)}\n\n")
            if chart_response.get("flag") == True:
                print("\n\nquery is showable in markdown\n\n")
                print(f"Markdown and HTML")
                return f"{markdown_response["markdown"]} \n {chart_response["i_Frame"]}"
        else:
            print(f"\n\nonly Markdown\n\n")
            return f"{markdown_response["markdown"]}"
    
    else:
        print(f"\n\nonly Markdown\n\n")
        return f"{markdown_response["markdown"]}"
    